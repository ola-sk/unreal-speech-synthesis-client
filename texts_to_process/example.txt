Requirements always change and most developers think this is a bad thing. But few of them write their code to handle changing requirements well. Requirements change for a very simple set of reasons:
The users view of their needs change as a result of their discussions with developers and from seeing new possibilities for the software. The developers view of the users problem domain changes as they develop software to automate it and thus become more familiar with it. The environment in which the software is being developed changes. This does not mean you and I can give up on gathering good requirements. It does mean that we must write our code to accommodate change.
Dealing with Changes: 
Using Functional Decomposition. Look a little closer at the problem of displaying shapes. How can I write the code so that it is easier to handle shifting requirements? Rather than writing one large function, I could make it more modular. Then, when I receive a requirement to be able to display a new type of shape, a triangle for instance, I only need to change this module. There are some problems with this approach, however. For example, I said that the inputs to the module were the type of shape and a description of the shape. Depending upon how I am storing shapes, it may or may not be possible to have a consistent description of shapes that will work well for all shapes. What if the description of the shape is sometimes stored as an array of points? Would that still work? Modularity definitely helps to make the code more understandable, and understandability makes the code easier to maintain. But modularity does not always help code deal with all of the variation it might encounter. With the approach that I have used so far, I find that I have two significant problems, which go by the terms low cohesion and tight coupling. The overwhelming amount of time spent in maintenance and debugging with this approach (no OOP) is on finding bugs and taking the time to avoid unwanted side effects. Since unwanted side effects are often the hardest bugs to find, having a function that touches many different pieces of data makes it more likely that a change in requirements will result in a problem. Functional decomposition focuses on the wrong thing and therefore we have Object Oriented Programming. he biggest difference is this shift of responsibility. In the first case, you are responsible for everything; in the second case, objectsts are responsible for their own behavior. At the conceptual level, an object is a set of responsibilities. At the specification level, an object is a set of methods that can be invoked by other objects or by itself. At the implementation level, an object is code and data and Objects are instances of classes. Class: The repository of methods and data that is shared by the objects. Defines the data members of objects. Code is organized around the class. encapsulation refers to the bundling of data with the mechanisms or methods that operate on the data. It may also refer to the limiting of direct access to some of that data, such as an object's components. Inheritance: Having one class be a special kind of another class. These specialized classes are called derivations of the base class (the initial class). The base class is called the superclass while the derived classes are called the subclasses. Instance: A particular example of a class (it is always an object). Instantiation: The process of creating an instance of a class. Polymorphism: Being able to refer to different derivations of a class in the same way, but getting the behavior appropriate to the derived class being referred to.
